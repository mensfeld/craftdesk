/**
 * GitIgnore Manager - Auto-generate .gitignore for managed vs embedded skills
 *
 * Handles:
 * - Generating .claude/skills/.gitignore to ignore managed dependencies
 * - Allowing embedded (local) skills to be committed
 * - Updating .gitignore when skills are added/removed
 */

import fs from 'fs-extra';
import path from 'path';
import { logger } from '../utils/logger';
import { configManager } from './config-manager';
import type { CraftDeskLock } from '../types/craftdesk-lock';

/**
 * Service for managing .gitignore in skills directory
 */
export class GitIgnoreManager {
  /**
   * Update .gitignore in skills directory to ignore managed skills
   *
   * @param skillsDir - Directory containing skills (e.g., '.claude/skills')
   * @param managedSkills - Array of managed skill names (from lockfile)
   * @param embeddedSkills - Array of embedded skill names (from craftdesk.json)
   * @param cwd - Current working directory (defaults to process.cwd())
   *
   * @example
   * ```typescript
   * const manager = new GitIgnoreManager();
   * await manager.updateGitIgnore(
   *   '.claude/skills',
   *   ['ruby-expert', 'postgres-expert'],  // Managed
   *   ['my-project-skill']                 // Embedded
   * );
   * ```
   */
  async updateGitIgnore(
    skillsDir: string,
    managedSkills: string[],
    embeddedSkills: string[],
    cwd: string = process.cwd()
  ): Promise<void> {
    const gitignorePath = path.join(cwd, skillsDir, '.gitignore');

    // Detect orphaned skills
    const orphaned = await this.detectOrphanedSkills(skillsDir, cwd);

    // Generate gitignore content
    const content = this.generateGitIgnoreContent(managedSkills, embeddedSkills, orphaned);

    // Ensure directory exists
    await fs.ensureDir(path.dirname(gitignorePath));

    // Write .gitignore
    await fs.writeFile(gitignorePath, content, 'utf-8');

    logger.debug(`Updated ${skillsDir}/.gitignore with ${managedSkills.length} managed and ${embeddedSkills.length} embedded skills`);
  }

  /**
   * Generate .gitignore file content
   *
   * @param managedSkills - Array of managed skill names
   * @param embeddedSkills - Array of embedded skill names
   * @param orphanedSkills - Array of orphaned skill names
   * @returns Generated .gitignore content
   * @private
   */
  private generateGitIgnoreContent(
    managedSkills: string[],
    embeddedSkills: string[],
    orphanedSkills: string[] = []
  ): string {
    const lines: string[] = [];

    // Header
    lines.push('# Auto-generated by CraftDesk - DO NOT EDIT');
    lines.push('# This file is managed automatically based on craftdesk.json and craftdesk.lock');
    lines.push('');

    if (managedSkills.length > 0) {
      lines.push('# Managed dependencies (from craftdesk.lock)');
      lines.push('# These are installed via `craftdesk install` and should not be committed');
      for (const skill of managedSkills.sort()) {
        lines.push(`${skill}/`);
      }
      lines.push('');
    }

    if (embeddedSkills.length > 0) {
      lines.push('# Embedded/local skills (committed to git)');
      lines.push('# These are project-specific and should be committed');
      for (const skill of embeddedSkills.sort()) {
        lines.push(`# NOT ignored: ${skill}/`);
      }
      lines.push('');
    }

    if (orphanedSkills.length > 0) {
      lines.push('# Untracked (not in craftdesk.json or craftdesk.lock)');
      lines.push('# Add these to dependencies or embedded list, or delete them');
      for (const skill of orphanedSkills.sort()) {
        lines.push(`# ${skill}/`);
      }
      lines.push('');
    }

    if (managedSkills.length === 0 && embeddedSkills.length === 0 && orphanedSkills.length === 0) {
      lines.push('# No managed or embedded skills yet');
      lines.push('# Run `craftdesk add <skill>` to add managed dependencies');
      lines.push('# Run `craftdesk embed <skill>` to register embedded skills');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Get managed skills from lockfile
   *
   * @param cwd - Current working directory (defaults to process.cwd())
   * @returns Array of managed skill names
   */
  async getManagedSkills(cwd: string = process.cwd()): Promise<string[]> {
    const lockfilePath = path.join(cwd, 'craftdesk.lock');

    if (!await fs.pathExists(lockfilePath)) {
      return [];
    }

    try {
      const lockfileContent = await fs.readFile(lockfilePath, 'utf-8');
      const lockfile: CraftDeskLock = JSON.parse(lockfileContent);

      // Get all craft names from lockfile where type is 'skill'
      return Object.entries(lockfile.crafts || {})
        .filter(([, entry]) => entry.type === 'skill')
        .map(([name]) => name);
    } catch (error) {
      logger.warn(`Failed to read lockfile: ${error}`);
      return [];
    }
  }

  /**
   * Get embedded skills from craftdesk.json
   *
   * @param cwd - Current working directory (defaults to process.cwd())
   * @returns Array of embedded skill names
   */
  async getEmbeddedSkills(cwd: string = process.cwd()): Promise<string[]> {
    const configPath = path.join(cwd, 'craftdesk.json');

    if (!await fs.pathExists(configPath)) {
      return [];
    }

    try {
      const configContent = await fs.readFile(configPath, 'utf-8');
      const config = JSON.parse(configContent);
      return config?.embedded || [];
    } catch (error) {
      logger.warn(`Failed to read craftdesk.json: ${error}`);
      return [];
    }
  }

  /**
   * Detect orphaned skills (in directory but not in lockfile or embedded list)
   *
   * @param skillsDir - Directory containing skills (e.g., '.claude/skills')
   * @param cwd - Current working directory (defaults to process.cwd())
   * @returns Array of orphaned skill names
   */
  async detectOrphanedSkills(
    skillsDir: string,
    cwd: string = process.cwd()
  ): Promise<string[]> {
    const fullSkillsDir = path.join(cwd, skillsDir);

    if (!await fs.pathExists(fullSkillsDir)) {
      return [];
    }

    // Get all directories in skills folder
    const entries = await fs.readdir(fullSkillsDir, { withFileTypes: true });
    const allSkills = entries
      .filter(entry => entry.isDirectory() && !entry.name.startsWith('.'))
      .map(entry => entry.name);

    // Get managed and embedded skills
    const managed = await this.getManagedSkills(cwd);
    const embedded = await this.getEmbeddedSkills(cwd);

    const knownSkills = new Set([...managed, ...embedded]);

    // Find orphans
    return allSkills.filter(skill => !knownSkills.has(skill));
  }

  /**
   * Update .gitignore after install/add/remove operations
   *
   * Convenience method that automatically fetches managed and embedded skills
   *
   * @param cwd - Current working directory (defaults to process.cwd())
   */
  async autoUpdate(cwd: string = process.cwd()): Promise<void> {
    const config = await configManager.getCraftDeskJson();
    const installPath = configManager.getInstallPath();
    const skillsDir = path.join(installPath, 'skills');

    const managed = await this.getManagedSkills(cwd);
    const embedded = config?.embedded || [];

    await this.updateGitIgnore(skillsDir, managed, embedded, cwd);
  }
}

// Export singleton instance
export const gitIgnoreManager = new GitIgnoreManager();

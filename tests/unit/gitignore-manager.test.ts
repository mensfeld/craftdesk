import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import { gitIgnoreManager } from '../../src/services/gitignore-manager';
import type { CraftDeskJson } from '../../src/types/craftdesk-json';
import type { CraftDeskLock } from '../../src/types/craftdesk-lock';

describe('GitIgnoreManager', () => {
  let tempDir: string;
  let skillsDir: string;

  beforeEach(async () => {
    // Create temp directory
    tempDir = await fs.mkdtemp(path.join(await fs.realpath('/tmp'), 'craftdesk-test-'));
    skillsDir = path.join(tempDir, '.claude', 'skills');
    await fs.ensureDir(skillsDir);

    // Create craftdesk.json
    const config: CraftDeskJson = {
      name: 'test-project',
      version: '1.0.0',
      dependencies: {
        'managed-skill': '1.0.0'
      },
      embedded: ['embedded-skill']
    };
    await fs.writeJson(path.join(tempDir, 'craftdesk.json'), config, { spaces: 2 });

    // Create craftdesk.lock
    const lock: CraftDeskLock = {
      version: '0.5.0',
      crafts: {
        'managed-skill': {
          name: 'managed-skill',
          version: '1.0.0',
          type: 'skill',
          resolved: 'https://example.com/managed-skill-1.0.0.tgz',
          integrity: 'sha512-abc123'
        }
      },
      pluginTree: {}
    };
    await fs.writeJson(path.join(tempDir, 'craftdesk.lock'), lock, { spaces: 2 });

    // Create skill directories
    await fs.ensureDir(path.join(skillsDir, 'managed-skill'));
    await fs.ensureDir(path.join(skillsDir, 'embedded-skill'));
    await fs.ensureDir(path.join(skillsDir, 'orphaned-skill'));

    // Change to temp directory
    process.chdir(tempDir);
  });

  afterEach(async () => {
    await fs.remove(tempDir);
  });

  describe('getManagedSkills', () => {
    it('should return list of managed skills from lockfile', async () => {
      const managed = await gitIgnoreManager.getManagedSkills(tempDir);
      expect(managed).toEqual(['managed-skill']);
    });

    it('should return empty array if lockfile does not exist', async () => {
      await fs.remove(path.join(tempDir, 'craftdesk.lock'));
      const managed = await gitIgnoreManager.getManagedSkills(tempDir);
      expect(managed).toEqual([]);
    });
  });

  describe('getEmbeddedSkills', () => {
    it('should return list of embedded skills from config', async () => {
      const embedded = await gitIgnoreManager.getEmbeddedSkills(tempDir);
      expect(embedded).toEqual(['embedded-skill']);
    });

    it('should return empty array if embedded field does not exist', async () => {
      const config = await fs.readJson(path.join(tempDir, 'craftdesk.json'));
      delete config.embedded;
      await fs.writeJson(path.join(tempDir, 'craftdesk.json'), config, { spaces: 2 });

      const embedded = await gitIgnoreManager.getEmbeddedSkills(tempDir);
      expect(embedded).toEqual([]);
    });

    it('should return empty array if config does not exist', async () => {
      await fs.remove(path.join(tempDir, 'craftdesk.json'));
      const embedded = await gitIgnoreManager.getEmbeddedSkills(tempDir);
      expect(embedded).toEqual([]);
    });
  });

  describe('detectOrphanedSkills', () => {
    it('should detect skills not in managed or embedded lists', async () => {
      const orphaned = await gitIgnoreManager.detectOrphanedSkills(
        '.claude/skills',
        tempDir
      );
      expect(orphaned).toEqual(['orphaned-skill']);
    });

    it('should return empty array if all skills are accounted for', async () => {
      await fs.remove(path.join(skillsDir, 'orphaned-skill'));
      const orphaned = await gitIgnoreManager.detectOrphanedSkills(
        '.claude/skills',
        tempDir
      );
      expect(orphaned).toEqual([]);
    });

    it('should return empty array if skills directory does not exist', async () => {
      const orphaned = await gitIgnoreManager.detectOrphanedSkills(
        'nonexistent',
        tempDir
      );
      expect(orphaned).toEqual([]);
    });
  });

  describe('updateGitIgnore', () => {
    it('should create .gitignore with managed skills', async () => {
      await gitIgnoreManager.updateGitIgnore(
        '.claude/skills',
        ['managed-skill'],
        ['embedded-skill'],
        tempDir
      );

      const gitignorePath = path.join(skillsDir, '.gitignore');
      expect(await fs.pathExists(gitignorePath)).toBe(true);

      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).toContain('managed-skill/');
      expect(content).toContain('# NOT ignored: embedded-skill/');
      expect(content).toContain('# Auto-generated by CraftDesk');
    });

    it('should add untracked section for orphaned skills', async () => {
      await gitIgnoreManager.updateGitIgnore(
        '.claude/skills',
        ['managed-skill'],
        ['embedded-skill'],
        tempDir
      );

      const gitignorePath = path.join(skillsDir, '.gitignore');
      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).toContain('# Untracked (not in craftdesk.json or craftdesk.lock)');
      expect(content).toContain('# orphaned-skill/');
    });

    it('should not include untracked section if no orphaned skills', async () => {
      await fs.remove(path.join(skillsDir, 'orphaned-skill'));
      await gitIgnoreManager.updateGitIgnore(
        '.claude/skills',
        ['managed-skill'],
        ['embedded-skill'],
        tempDir
      );

      const gitignorePath = path.join(skillsDir, '.gitignore');
      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).not.toContain('# Untracked');
    });

    it('should overwrite existing .gitignore', async () => {
      const gitignorePath = path.join(skillsDir, '.gitignore');
      await fs.writeFile(gitignorePath, '# Old content\nold-skill/\n');

      await gitIgnoreManager.updateGitIgnore(
        '.claude/skills',
        ['managed-skill'],
        ['embedded-skill'],
        tempDir
      );

      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).not.toContain('old-skill/');
      expect(content).toContain('managed-skill/');
    });

    it('should handle empty managed skills list', async () => {
      await gitIgnoreManager.updateGitIgnore(
        '.claude/skills',
        [],
        ['embedded-skill'],
        tempDir
      );

      const gitignorePath = path.join(skillsDir, '.gitignore');
      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).toContain('# Auto-generated by CraftDesk');
      expect(content).not.toContain('managed-skill/');
    });
  });

  describe('autoUpdate', () => {
    it('should automatically update .gitignore based on config and lockfile', async () => {
      await gitIgnoreManager.autoUpdate(tempDir);

      const gitignorePath = path.join(skillsDir, '.gitignore');
      expect(await fs.pathExists(gitignorePath)).toBe(true);

      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).toContain('managed-skill/');
      expect(content).toContain('# NOT ignored: embedded-skill/');
    });

    it('should handle missing craftdesk.json gracefully', async () => {
      await fs.remove(path.join(tempDir, 'craftdesk.json'));
      await expect(gitIgnoreManager.autoUpdate(tempDir)).resolves.not.toThrow();
    });

    it('should handle missing craftdesk.lock gracefully', async () => {
      await fs.remove(path.join(tempDir, 'craftdesk.lock'));
      await gitIgnoreManager.autoUpdate(tempDir);

      const gitignorePath = path.join(skillsDir, '.gitignore');
      const content = await fs.readFile(gitignorePath, 'utf-8');
      // managed-skill becomes orphaned when lockfile is removed
      expect(content).toContain('# managed-skill/');
      // embedded-skill should still be marked as not ignored
      expect(content).toContain('# NOT ignored: embedded-skill/');
    });
  });

  describe('edge cases', () => {
    it('should handle skill names with special characters', async () => {
      const specialSkill = 'skill-with-special.chars_123';
      await fs.ensureDir(path.join(skillsDir, specialSkill));

      // Read, update, and write config
      const configPath = path.join(tempDir, 'craftdesk.json');
      const config = await fs.readJson(configPath);
      config.embedded = [specialSkill];
      await fs.writeJson(configPath, config, { spaces: 2 });

      // Verify the config was written
      const verifyConfig = await fs.readJson(configPath);
      expect(verifyConfig.embedded).toEqual([specialSkill]);

      // Update gitignore manually with the special skill
      await gitIgnoreManager.updateGitIgnore(
        '.claude/skills',
        [],
        [specialSkill],
        tempDir
      );

      const gitignorePath = path.join(skillsDir, '.gitignore');
      const content = await fs.readFile(gitignorePath, 'utf-8');
      expect(content).toContain(`# NOT ignored: ${specialSkill}/`);
    });

    it('should handle both agents and skills directories', async () => {
      const agentsDir = path.join(tempDir, '.claude', 'agents');
      await fs.ensureDir(agentsDir);
      await fs.ensureDir(path.join(agentsDir, 'test-agent'));

      // Note: Current implementation only handles skills
      // This test documents expected future behavior
      await gitIgnoreManager.autoUpdate(tempDir);

      const gitignorePath = path.join(skillsDir, '.gitignore');
      expect(await fs.pathExists(gitignorePath)).toBe(true);
    });

    it('should handle concurrent updates gracefully', async () => {
      // Run multiple auto-updates in parallel
      await Promise.all([
        gitIgnoreManager.autoUpdate(tempDir),
        gitIgnoreManager.autoUpdate(tempDir),
        gitIgnoreManager.autoUpdate(tempDir)
      ]);

      const gitignorePath = path.join(skillsDir, '.gitignore');
      expect(await fs.pathExists(gitignorePath)).toBe(true);

      const content = await fs.readFile(gitignorePath, 'utf-8');
      // Should have the managed skill from the lockfile
      expect(content).toContain('managed-skill/');
      // Should have the embedded skill as NOT ignored
      expect(content).toContain('# NOT ignored: embedded-skill/');
    });
  });
});
